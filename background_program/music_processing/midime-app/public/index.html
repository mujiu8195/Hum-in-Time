<!DOCTYPE html>
<html lang="en">
  <head>
    <title>MidiMe TouchDesigner Integration</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.9.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.8/FileSaver.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,700&display=swap" rel="stylesheet">
    <style>
      :root {
        --green: #9DE5B8;
        --blue: #23465A;
        --cream: #DEF2F1;
        --purple: #7A5C85;
        --slider-size: 20px;
        --thumb-size: 10px;
      }
      
      body {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 16px;
        margin: 0;
        padding: 20px;
        background: var(--cream);
        color: var(--blue);
        line-height: 1.5;
        text-align: center;
      }
      
      * { box-sizing: border-box; }
      
      [hidden] {
        display: none !important;
      }
      
      [disabled] {
        opacity: 0.3;
        pointer-events: none;
      }
      
      h1 {
        font-size: 40px;
        font-weight: normal;
        margin-top: 0;
      }
      
      .container {
        max-width: 900px;
        margin: 0 auto;
        background: white;
        border-radius: 5px;
        padding: 30px;
        text-align: left;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      
      .horizontal {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
      }
      
      .button {
        display: inline-block;
        font-family: inherit;
        font-weight: bold;
        transition: all 0.2s linear;
        text-align: center;
        padding: 10px 20px;
        margin: 10px 5px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 16px;
        background: var(--blue);
        color: white;
      }
      
      .button:hover {
        background: var(--green);
        color: var(--blue);
      }
      
      .button-play {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        padding: 0;
        position: relative;
      }
      
      .button-play svg {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 24px;
        height: 24px;
        fill: white;
      }
      
      .visualizer-container {
        overflow: auto;
        min-height: 100px;
        background: var(--cream);
        border: 2px solid var(--blue);
        margin: 10px 0;
        position: relative;
      }
      
      .sliders-container {
        background: var(--purple);
        color: white;
        padding: 20px;
        border-radius: 5px;
        margin: 20px 0;
      }
      
      .sliders {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
      }
      
      .range-wrap {
        width: 80px;
        text-align: center;
        margin: 0 10px;
      }
      
      .range-wrap label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      
      input[type=range] {
        width: 100%;
        -webkit-appearance: none;
        background: transparent;
      }
      
      input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 20px;
        width: 20px;
        border-radius: 50%;
        background: var(--green);
        margin-top: -8px;
        cursor: pointer;
      }
      
      input[type=range]::-webkit-slider-runnable-track {
        height: 4px;
        background: var(--cream);
      }

      input[type=number] {
        width: 60px;
        padding: 5px;
        border: 1px solid var(--blue);
        border-radius: 3px;
        font-family: inherit;
        font-size: 14px;
      }
      
      #errorGraph {
        width: 100%;
        height: 200px;
        background: white;
        border: 1px solid var(--blue);
      }
      
      #status {
        font-weight: bold;
        color: var(--blue);
        margin: 10px 0;
        padding: 10px;
        border-radius: 3px;
      }
      
      .progress-container {
        margin: 20px 0;
        background: #eee;
        border-radius: 3px;
        height: 20px;
        position: relative;
      }
      
      .progress-bar {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background: var(--green);
        border-radius: 3px;
        transition: width 0.2s;
      }
      
      .td-integration {
        background-color: var(--purple);
        color: white;
        padding: 15px;
        border-radius: 5px;
        margin-top: 20px;
      }
      
      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--blue);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 1000;
      }
      
      .notification.show {
        opacity: 1;
      }
      
      .file-info {
        background-color: var(--cream);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 20px;
      }

      .config-section {
        background-color: #f0f0f0;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
      }

      .channel-info {
        background-color: #e8f4f8;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        font-size: 14px;
      }
    </style>
  </head>  
  <body>
    <div class="container">
      <h1>midi<b>me</b> <small>TD Integration</small></h1>
      
      <div id="td-status" class="td-integration">
        <h2>TouchDesigner 连接状态</h2>
        <p>状态: <span id="connection-status">等待连接...</span></p>
        <p>上次参数更新: <span id="last-update">从未</span></p>
      </div>
      
      <div id="config-section" class="config-section">
        <h3>配置</h3>
        <div>
          <label for="training-epochs">训练次数: </label>
          <input type="number" id="training-epochs" min="1" max="100" value="5">
          <button id="apply-epochs" class="button">应用</button>
        </div>
        <p>当前训练次数: <span id="current-epochs">5</span></p>
        
        <div class="channel-info">
          <strong>MIDI通道配置：</strong><br>
          通道 0: 钢琴 (Piano)<br>
          通道 1: 小提琴 (Violin)<br>
          通道 2: 鼓组 (Drums)<br>
          <em>所有保存的MIDI文件将自动确保包含这3个通道</em>
        </div>
      </div>
      
      <div id="file-info" class="file-info" hidden>
        <h3>当前文件</h3>
        <p>文件路径: <span id="current-file-path">无</span></p>
        <p>输出目录: <span id="output-directory">H:\code\Graduation_project\music_processing\midiPlay\3_music</span></p>
        <p>通道状态: <span id="channel-status">等待分析...</span></p>
      </div>
      
      <div id="inputSection" hidden>
        <h2>MIDI Input Preview</h2>
        <div id="status"></div>
        
        <div id="input">
          <p>Input MIDI preview:</p>
          <div class="visualizer-container">
            <button id="btnPlayInput" class="button button-play" aria-label="play">
              <svg class="iconPlay" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
              <svg class="iconStop" hidden xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>
            </button>
            <svg id="vizInput"></svg>
          </div>
        </div>
      </div>
      
      <div id="trainingSection" hidden>
        <h2>Training Progress</h2>
        <p>Training step: <span id="trainingStep">0</span> / <span id="totalSteps">5</span></p>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>
        <svg id="errorGraph"></svg>
      </div>
      
      <div id="generationSection" hidden>
        <h2>Generated Music</h2>
        <p>滑块参数与TouchDesigner同步。当前参数:</p>
        
        <div class="sliders-container">
          <p>Super Sliders:</p>
          <div class="sliders" id="midimeSliders">
            <div class="range-wrap">
              <label>Parameter 1</label>
              <input type="range" data-index="0" min="-1" max="1" step="0.1" value="0" disabled>
            </div>
            <div class="range-wrap">
              <label>Parameter 2</label>
              <input type="range" data-index="1" min="-1" max="1" step="0.1" value="0" disabled>
            </div>
            <div class="range-wrap">
              <label>Parameter 3</label>
              <input type="range" data-index="2" min="-1" max="1" step="0.1" value="0" disabled>
            </div>
            <div class="range-wrap">
              <label>Parameter 4</label>
              <input type="range" data-index="3" min="-1" max="1" step="0.1" value="0" disabled>
            </div>
          </div>
        </div>
        
        <p>Generated output:</p>
        <div class="visualizer-container">
          <button id="btnPlaySample" class="button button-play" aria-label="play">
            <svg class="iconPlay" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            <svg class="iconStop" hidden xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>
          </button>
          <svg id="vizSample"></svg>
        </div>
        
        <div class="horizontal">
          <p>等待TouchDesigner发送生成指令...</p>
        </div>
      </div>
    </div>
    
    <div id="notification" class="notification"></div>

    <script>
      // API 端点
      const API_BASE = 'http://localhost:5000';
      const WS_URL = 'ws://localhost:5001';
      
      // Constants
      const TRIO_DIMS = [132,68,160,36,105,248,75,152,135,18,246,1,77,79,7,163,87,63,72,162,236,0,221,108,29,98,78,203,166,173,69,74,129,125,142,53,8,156,52,85,189,133,206,25,65,94,253,71,233,33,31,176,116,64,131,255,159,83,35,195,214,139,127,134,86,70,165,177,194,137,187,113,190,37,161,58,151,81,210,183,62,179,218,254,230,27,222,115,73,192,112,175,145,3,229,217,251,169,90,167,11,186,120,242,208,17,150,92,215,191,209,184,46,34,188,51,60,171,12,24,250,16,38,104,172,117,128,50,212,114,95,21,2,158,96,136,147,252,126,47,43,30,19,84,91,205,42,196,234,243,146,149,13,226,225,157,22,219,138,28,103,14,101,124,200,76,174,182,238,202,100,239,198,130,141,97,66,44,56,9,123,61,231,223,244,111,247,45,153,67,232,109,41,143,201,119,5,185,154,4,170,249,99,55,15,39,26,245,197,168,106,121,6,204,213,155,23,49,118,227,57,88,80,199,211,48,82,240,144,107,89,178,216,20,148,237,207,235,224,228,180,110,193,54,181,140,241,93,59,102,220,32,10,164,40,122];
      const MODEL_BARS = 4;
      let TRAINING_STEPS = 5; // 默认改为5

      // DOM Elements
      const btnPlayInput = document.getElementById('btnPlayInput');
      const btnPlaySample = document.getElementById('btnPlaySample');
      const statusEl = document.getElementById('status');
      const midimeSliders = document.getElementById('midimeSliders');
      const trainingStepEl = document.getElementById('trainingStep');
      const totalStepsEl = document.getElementById('totalSteps');
      const progressBarEl = document.getElementById('progressBar');
      const connectionStatusEl = document.getElementById('connection-status');
      const lastUpdateEl = document.getElementById('last-update');
      const notificationEl = document.getElementById('notification');
      const currentFilePathEl = document.getElementById('current-file-path');
      const outputDirectoryEl = document.getElementById('output-directory');
      const trainingEpochsInput = document.getElementById('training-epochs');
      const currentEpochsEl = document.getElementById('current-epochs');
      const applyEpochsBtn = document.getElementById('apply-epochs');
      const channelStatusEl = document.getElementById('channel-status');

      // Models
      let mvae;
      let midime;

      // Players
      let playerInput;
      let playerSample;

      // Visualizers
      let vizInput;
      let vizSample;

      // Data
      let inputSequence;
      let currentSample;
      let playerSaidStop = false;
      let training = {};
      let websocket;
      let currentParams = [0, 0, 0, 0];
      let outputDirectory = 'H:\\code\\Graduation_project\\music_processing\\midiPlay\\3_music';
      let currentFilePath = null;
      
      // 当前活跃文件
      let activeFile = null;

      // 三通道MIDI处理函数
      function ensureThreeChannels(noteSequence) {
        const processedSequence = JSON.parse(JSON.stringify(noteSequence));
        
        if (!processedSequence.notes) {
          processedSequence.notes = [];
        }
        
        const existingChannels = new Set();
        processedSequence.notes.forEach(note => {
          if (note.instrument !== undefined) {
            existingChannels.add(note.instrument);
          }
        });
        
        if (existingChannels.size >= 3) {
          return processedSequence;
        }
        
        const targetChannels = [0, 1, 2];
        
        if (processedSequence.notes.length === 0) {
          const baseDuration = 0.5;
          const baseVelocity = 80;
          
          targetChannels.forEach((channel, index) => {
            processedSequence.notes.push({
              startTime: index * 0.1,
              endTime: index * 0.1 + baseDuration,
              pitch: 60 + index * 4,
              velocity: baseVelocity,
              instrument: channel,
              program: getDefaultProgram(channel)
            });
          });
        } else {
          const originalNotes = [...processedSequence.notes];
          const missingChannels = targetChannels.filter(ch => !existingChannels.has(ch));
          
          missingChannels.forEach((missingChannel, index) => {
            const notesToCopy = originalNotes.slice(0, Math.max(1, Math.floor(originalNotes.length / 3)));
            
            notesToCopy.forEach(note => {
              const newNote = {
                ...note,
                instrument: missingChannel,
                program: getDefaultProgram(missingChannel),
                pitch: Math.max(0, Math.min(127, note.pitch + (missingChannel - (existingChannels.values().next().value || 0)) * 2))
              };
              processedSequence.notes.push(newNote);
            });
          });
        }
        
        processedSequence.notes.forEach(note => {
          if (note.instrument === undefined) {
            note.instrument = 0;
          }
          if (note.program === undefined) {
            note.program = getDefaultProgram(note.instrument);
          }
        });
        
        if (processedSequence.notes.length > 0) {
          processedSequence.totalTime = Math.max(...processedSequence.notes.map(note => note.endTime));
        }
        
        if (!processedSequence.instrumentInfos) {
          processedSequence.instrumentInfos = [];
        }
        
        targetChannels.forEach(channel => {
          const existingInfo = processedSequence.instrumentInfos.find(info => info.instrument === channel);
          if (!existingInfo) {
            processedSequence.instrumentInfos.push({
              instrument: channel,
              program: getDefaultProgram(channel),
              name: getInstrumentName(channel)
            });
          }
        });
        
        return processedSequence;
      }

      function getDefaultProgram(channel) {
        const programs = {
          0: 1,   // 钢琴
          1: 41,  // 小提琴
          2: 129  // 鼓组
        };
        return programs[channel] || 1;
      }

      function getInstrumentName(channel) {
        const names = {
          0: "Piano",
          1: "Violin", 
          2: "Drums"
        };
        return names[channel] || "Piano";
      }

      function validateThreeChannels(noteSequence) {
        if (!noteSequence.notes || noteSequence.notes.length === 0) {
          return false;
        }
        
        const channels = new Set();
        noteSequence.notes.forEach(note => {
          if (note.instrument !== undefined) {
            channels.add(note.instrument);
          }
        });
        
        return channels.size >= 3;
      }

      function updateChannelStatus(noteSequence) {
        if (!noteSequence || !noteSequence.notes) {
          channelStatusEl.textContent = '无音符数据';
          return;
        }

        const channels = new Set();
        noteSequence.notes.forEach(note => {
          if (note.instrument !== undefined) {
            channels.add(note.instrument);
          }
        });

        const channelArray = Array.from(channels).sort();
        channelStatusEl.textContent = `检测到 ${channelArray.length} 个通道: [${channelArray.join(', ')}]`;
        
        if (channelArray.length >= 3) {
          channelStatusEl.style.color = 'green';
        } else {
          channelStatusEl.style.color = 'orange';
        }
      }

      // Initialize
      init();

      function init() {
        showNotification('正在初始化系统...');
        statusEl.textContent = '正在加载模型...';
        
        setupWebSocket();
        
        const url = 'https://storage.googleapis.com/magentadata/js/checkpoints/music_vae/trio_4bar';
        mvae = new mm.MusicVAE(url);
        
        playerInput = new mm.SoundFontPlayer('https://storage.googleapis.com/magentadata/js/soundfonts/sgm_plus');
        playerSample = new mm.SoundFontPlayer('https://storage.googleapis.com/magentadata/js/soundfonts/sgm_plus');
        
        playerInput.callbackObject = {
          run: (note) => vizInput && vizInput.redraw(note, true),
          stop: () => {}
        };
        
        playerSample.callbackObject = {
          run: (note) => vizSample && vizSample.redraw(note, true),
          stop: () => {}
        };

        btnPlayInput.addEventListener('click', (e) => play(e, playerInput, inputSequence, btnPlayInput));
        btnPlaySample.addEventListener('click', (e) => play(e, playerSample, currentSample, btnPlaySample));
        
        applyEpochsBtn.addEventListener('click', setTrainingEpochs);

        mvae.initialize().then(() => {
          statusEl.textContent = '模型已加载。等待TouchDesigner发送指令...';
          showNotification('模型加载完成，等待TD指令');
          
          midime = new mm.MidiMe({epochs: TRAINING_STEPS});
          midime.initialize();
        }).catch(error => {
          statusEl.textContent = '加载模型错误: ' + error.message;
          showNotification('模型加载失败');
        });
      }
      
      function setTrainingEpochs() {
        const epochs = parseInt(trainingEpochsInput.value);
        if (isNaN(epochs) || epochs < 1 || epochs > 100) {
          showNotification('请输入有效的训练次数（1-100之间）');
          return;
        }
        
        TRAINING_STEPS = epochs;
        totalStepsEl.textContent = epochs;
        currentEpochsEl.textContent = epochs;
        
        midime = new mm.MidiMe({epochs: TRAINING_STEPS});
        midime.initialize();
        
        fetch(`${API_BASE}/set_default_epochs`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ epochs: epochs })
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            showNotification(`训练次数已设置为 ${epochs}`);
          } else {
            showNotification('设置训练次数失败: ' + data.error);
          }
        })
        .catch(error => {
          console.error('设置训练次数错误:', error);
          showNotification('设置训练次数错误: ' + error.message);
        });
      }
      
      function setupWebSocket() {
        websocket = new WebSocket(WS_URL);
        
        websocket.onopen = () => {
          console.log('WebSocket连接已建立');
          connectionStatusEl.textContent = '已连接';
          showNotification('WebSocket连接已建立');
        };
        
        websocket.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            console.log('收到WebSocket消息:', message);
            
            switch (message.type) {
              case 'start_training':
                handleTrainingRequest(message.data);
                break;
                
              case 'update_params':
                updateParamsFromTD(message.data.params);
                break;
                
              case 'generate_midi':
                generateAndSaveMidi(message.data);
                break;
                
              case 'model_trained':
                showNotification('已有训练好的模型');
                break;
            }
          } catch (error) {
            console.error('处理WebSocket消息错误:', error);
          }
        };
        
        websocket.onclose = () => {
          console.log('WebSocket连接已关闭');
          connectionStatusEl.textContent = '连接已断开';
          setTimeout(setupWebSocket, 5000);
        };
        
        websocket.onerror = (error) => {
          console.error('WebSocket错误:', error);
          connectionStatusEl.textContent = '连接错误';
        };
      }
      
      async function handleTrainingRequest(data) {
        showNotification('收到训练请求');
        document.getElementById('trainingSection').hidden = false;
        document.getElementById('file-info').hidden = false;
        document.getElementById('inputSection').hidden = false;
        
        const { file_path, epochs } = data;
        currentFilePath = file_path;
        currentFilePathEl.textContent = file_path;
        
        if (epochs) {
          TRAINING_STEPS = epochs;
          totalStepsEl.textContent = epochs;
          trainingEpochsInput.value = epochs;
          currentEpochsEl.textContent = epochs;
          
          midime = new mm.MidiMe({epochs: TRAINING_STEPS});
          midime.initialize();
        }
        
        try {
          statusEl.textContent = '正在加载MIDI文件...';
          showNotification('正在加载MIDI文件');
          
          const response = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(file_path)}`);
          if (!response.ok) {
            throw new Error(`无法加载文件: ${response.status} ${response.statusText}`);
          }
          
          const midiBlob = await response.blob();
          inputSequence = await mm.blobToNoteSequence(midiBlob);
          
          // 更新通道状态显示
          updateChannelStatus(inputSequence);
          
          vizInput = new mm.PianoRollSVGVisualizer(
            inputSequence,
            document.getElementById('vizInput'),
            {noteRGB:'35,70,90', activeNoteRGB:'157, 229, 184', noteHeight:3}
          );
          
          playerInput.loadSamples(inputSequence);
          
          statusEl.textContent = '开始训练...';
          trainingStepEl.textContent = '0';
          progressBarEl.style.width = '0%';
          
          const quantizedSequence = mm.sequences.quantizeNoteSequence(inputSequence, 4);
          const chunks = mm.sequences.split(mm.sequences.clone(quantizedSequence), 16 * MODEL_BARS);
          const z = await mvae.encode(chunks);
          training.z = z;
          
          const losses = [];
          
          await midime.train(training.z, async (epoch, logs) => {
            await mm.tf.nextFrame();
            trainingStepEl.textContent = epoch + 1;
            progressBarEl.style.width = `${(epoch + 1) / TRAINING_STEPS * 100}%`;
            losses.push(logs.total);
            plotLoss(losses);
            
            if (websocket.readyState === WebSocket.OPEN) {
              websocket.send(JSON.stringify({
                type: 'training_progress',
                data: {
                  epoch: epoch + 1,
                  total: TRAINING_STEPS,
                  loss: logs.total
                }
              }));
            }
            
            fetch(`${API_BASE}/training_status`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                status: 'in_progress',
                progress: (epoch + 1) / TRAINING_STEPS,
                model_info: {
                  epoch: epoch + 1,
                  total: TRAINING_STEPS,
                  loss: logs.total
                }
              })
            }).catch(err => console.error('发送训练状态错误:', err));
          });
          
          statusEl.textContent = '训练完成！';
          showNotification('训练完成');
          document.getElementById('generationSection').hidden = false;
          
          await generateSample();
          
          if (websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
              type: 'training_complete',
              data: {
                file_path: file_path,
                epochs: TRAINING_STEPS,
                timestamp: new Date().toISOString()
              }
            }));
          }
          
          fetch(`${API_BASE}/training_status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              status: 'completed',
              model_info: {
                file_path: file_path,
                epochs: TRAINING_STEPS,
                timestamp: new Date().toISOString()
              }
            })
          }).catch(err => console.error('发送训练完成状态错误:', err));
        } catch (error) {
          console.error('训练错误:', error);
          statusEl.textContent = '训练错误: ' + error.message;
          showNotification('训练失败: ' + error.message);
          
          if (websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
              type: 'training_error',
              data: {
                error: error.message
              }
            }));
          }
        }
      }
      
      function updateParamsFromTD(params) {
        if (!params || params.length !== 4) return;
        
        const sliders = midimeSliders.querySelectorAll('input');
        for (let i = 0; i < 4; i++) {
          sliders[i].value = params[i];
          currentParams[i] = params[i];
        }
        
        lastUpdateEl.textContent = new Date().toLocaleTimeString();
        showNotification('参数已从TouchDesigner更新');
      }
      
      async function generateAndSaveMidi(data) {
        showNotification('收到生成请求');
        statusEl.textContent = '正在生成MIDI...';
        
        const { params, save_path, file_name } = data;
        
        try {
          if (params && params.length === 4) {
            currentParams = params;
            updateParamsFromTD(params);
          }
          
          await generateSample();
          
          if (currentSample) {
            // 确保生成的MIDI有三个通道
            const processedSample = ensureThreeChannels(currentSample);
            
            // 验证处理结果
            const isValid = validateThreeChannels(processedSample);
            console.log('三通道验证结果:', isValid);
            
            // 更新通道状态显示
            updateChannelStatus(processedSample);
            
            const savePath = save_path || outputDirectory;
            const fileName = file_name || 'music_output.mid';
            
            const midiData = mm.sequenceProtoToMidi(processedSample);
            const blob = new Blob([midiData], {type: 'audio/midi'});
            const reader = new FileReader();
            
            reader.onload = async () => {
              const base64data = reader.result;
              
              const response = await fetch(`${API_BASE}/api/save`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  outputPath: savePath,
                  fileName: fileName,
                  fileData: base64data
                })
              });
              
              const result = await response.json();
              
              if (result.error) {
                statusEl.textContent = '保存错误: ' + result.error;
                showNotification('保存失败: ' + result.error);
              } else {
                statusEl.textContent = `MIDI已保存到 ${result.path} (${isValid ? '✓' : '✗'} 三通道)`;
                showNotification(`MIDI文件已保存: ${fileName} (包含3个通道)`);
                
                if (websocket.readyState === WebSocket.OPEN) {
                  websocket.send(JSON.stringify({
                    type: 'save_complete',
                    data: {
                      file_path: result.path,
                      channels: isValid ? 3 : 'unknown'
                    }
                  }));
                }
                
                fetch(`${API_BASE}/generation_status`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    status: 'saved',
                    file_path: result.path,
                    channels: isValid ? 3 : 'unknown'
                  })
                }).catch(err => console.error('发送生成状态错误:', err));
              }
            };
            
            reader.readAsDataURL(blob);
          } else {
            throw new Error('没有生成的样本可保存');
          }
        } catch (error) {
          console.error('生成错误:', error);
          statusEl.textContent = '生成错误: ' + error.message;
          showNotification('生成失败: ' + error.message);
          
          if (websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
              type: 'generation_error',
              data: {
                error: error.message
              }
            }));
          }
        }
      }
      
      async function generateSample() {
        stopPlayer(playerSample, btnPlaySample);
        statusEl.textContent = '生成新样本...';
        
        try {
          if (midime && midime.trained) {
            const z = mm.tf.tensor(currentParams, [1, 4]);
            const sample = await midime.decode(z);
            currentSample = (await mvae.decode(sample))[0];
            
            // 确保生成的样本有三个通道
            currentSample = ensureThreeChannels(currentSample);
            
            // 更新通道状态显示
            updateChannelStatus(currentSample);
            
            vizSample = new mm.PianoRollSVGVisualizer(
              currentSample,
              document.getElementById('vizSample'),
              {noteRGB:'35,70,90', activeNoteRGB:'157, 229, 184', noteHeight:100}
            );
            
            playerSample.loadSamples(currentSample);
            
            const isValid = validateThreeChannels(currentSample);
            statusEl.textContent = `样本已生成 (${isValid ? '✓' : '✗'} 三通道)`;
            z.dispose();
            sample.dispose();
          } else {
            statusEl.textContent = '请先训练模型';
            showNotification('请先训练模型');
          }
        } catch (error) {
          console.error('生成样本错误:', error);
          statusEl.textContent = '生成样本错误: ' + error.message;
        }
      }

      function play(event, player, melody, btn) {
        if (player.isPlaying()) {
          stopPlayer(player, btn);
        } else {
          startPlayer(player, btn);
          player.start(melody).then(() => {
            stopPlayer(player, btn);
          });
        }
      }

      function stopPlayer(player, btn) {
        player.stop();
        playerSaidStop = true;
        btn.querySelector('.iconPlay').removeAttribute('hidden');
        btn.querySelector('.iconStop').setAttribute('hidden', true);
      }

      function startPlayer(player, btn) {
        playerSaidStop = false;
        btn.querySelector('.iconStop').removeAttribute('hidden');
        btn.querySelector('.iconPlay').setAttribute('hidden', true);
      }

      function showNotification(message) {
        notificationEl.textContent = message;
        notificationEl.classList.add('show');
        
        setTimeout(() => {
          notificationEl.classList.remove('show');
        }, 3000);
      }

      function plotLoss(data) {
        const svg = document.getElementById('errorGraph');
        svg.innerHTML = '';
        
        if (data.length < 2) return;
        
        const width = svg.clientWidth;
        const height = svg.clientHeight;
        const padding = 30;
        const maxLoss = Math.max(...data);
        
        const xScale = (width - padding*2) / (data.length - 1);
        const yScale = (height - padding*2) / maxLoss;
        
        let pathData = `M ${padding} ${height - padding - data[0] * yScale}`;
        
        for (let i = 1; i < data.length; i++) {
          pathData += ` L ${padding + i * xScale} ${height - padding - data[i] * yScale}`;
        }
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('stroke', '#23465A');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('fill', 'none');
        
        svg.appendChild(path);
        
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding);
        xAxis.setAttribute('y1', height - padding);
        xAxis.setAttribute('x2', width - padding);
        xAxis.setAttribute('y2', height - padding);
        xAxis.setAttribute('stroke', '#23465A');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding);
        yAxis.setAttribute('y1', padding);
        yAxis.setAttribute('x2', padding);
        yAxis.setAttribute('y2', height - padding);
        yAxis.setAttribute('stroke', '#23465A');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
      }
    </script>
  </body>
</html>